# Задание (Неделя 1): Django + Postgres модуль-каркас сервиса + мини-фронт

## Цель задания
Собрать минимальный «каркас» будущего ML‑сервиса. Сейчас в нём **нет** машинного обучения. Это заготовка, в которую на следующих неделях будут добавляться данные, обучение, оценка, версии моделей и endpoints `/predict`, `/ask`.

Каркас нужен, чтобы у всех был одинаковый стандарт: одна команда запуска, одинаковые URL, единая структура папок, проверка доступности базы, и простая веб‑страница статуса.

## Что должно получиться в итоге
После выполнения задания любой человек (преподаватель/одногруппник), следуя README, сможет:
 
1) открыть страницу в браузере и увидеть статус сервиса;  
2) сделать запрос `GET /health` и получить JSON;  
3) убедиться, что сервис видит базу (`db=ok`) или не видит (`db=fail`) при выключенном Postgres.

---

## 1) Функциональные требования

### 1.1. Endpoint: `GET /health`
Назначение: техническая проверка, что сервис «жив» и Postgres доступен.

Требования к ответу:
- `Content-Type: application/json`
- Если всё OK: **HTTP 200**
- Если БД недоступна: **HTTP 503**
- Тело ответа **всегда** JSON со следующими полями:

Обязательные поля:
- `status`: `"ok"` | `"fail"`
- `db`: `"ok"` | `"fail"`
- `time`: строка времени (ISO8601, можно timezone-naive, но лучше UTC)
- `app_version`: строка (можно `"dev"`, но лучше короткий git sha или переменная `VERSION`)

Пример (OK):
```json
{
  "status": "ok",
  "db": "ok",
  "time": "2026-02-02T10:00:00Z",
  "app_version": "dev"
}
```

Логика проверки `db`:
- выполнить быстрый запрос к БД `SELECT 1` через Django `connection`;
- если запрос прошёл — `db="ok"`, иначе `db="fail"`.

---

### 1.2. Мини‑фронт: `GET /` (или `/ui`)
Назначение: проверять сервис **без** curl/Postman. Это не «настоящий фронтенд», а одна HTML‑страница.

Требования:
- Страница показывает:
  - Заголовок (название проекта)
  - Строки: **Service status**, **DB status**, **Time**, **Version**
  - Кнопка **Refresh** (обновить статус)
- Страница делает `fetch` к `/health` и подставляет значения.
- Если `/health` отдаёт **503**, страница всё равно должна отобразить `db=fail` (и/или `status=fail`) — **не падать** белым экраном.

Допускается реализация:
- Django template + встроенный JS (самый простой вариант);
- либо статический HTML в `templates/`.

---

## 2) Нефункциональные требования (инженерные)

### 2.1. Структура проекта (единый стандарт)
В репозитории должна быть папочная структура (можно пустые папки, но должны существовать):

- `apps/`
  - `core/` (health, общие утилиты)
  - `api/` (URLs/контракты, можно минимально)
  - `ml/` (пока заглушка, но папка и интерфейс должны быть)
  - `data/` (пока пусто, под БД/ETL позже)
- `config/` (settings/urls/asgi/wsgi)
- `artifacts/`
  - `models/`
  - `metrics/`
  - `configs/`
  - `splits/`
- `reports/`

Зачем эти папки:
- `apps/core` — «сервисная часть» (health, common)
- `apps/api` — сюда будут добавляться `/predict` и `/ask`
- `apps/ml` — «слой модели»: позже сюда положим загрузку модели и `predict()`
- `apps/data` — позже ETL и модели БД
- `artifacts/` и `reports/` — единое место под результаты и документы следующих недель

---

## 3) Требования к ML‑модулю (пока заглушка)

В `apps/ml/` должен быть файл (например, `service.py`) с функциями‑скелетами:

- `load_model(version: str | None = None) -> object`
- `predict(payload: dict) -> dict`
- `get_model_meta() -> dict`

На этой неделе они могут возвращать заглушки, например:
- `load_model` возвращает `None` или простой объект;
- `predict` возвращает `{"prediction": null}`;
- `get_model_meta` возвращает `{"model_version": "none"}`.

Зачем это требуется сейчас: чтобы позже `/predict` подключался **без** переделки структуры проекта.

---

## 4) Deliverables (что сдаётся)

Вы сдаёте ссылку на репозиторий, в котором:

1) Django проект запускается по README  
2) Работает `/health` по формату и кодам **200/503**  
3) Работает мини‑фронт на `/` или `/ui`  
4) Подключён Postgres (и миграции проходят)  
5) Есть структура папок (`apps/*`, `artifacts/*`, `reports/`)  
6) Есть `.env.example`  
7) Есть «одна команда запуска» (Makefile или scripts)

---

## 5) Критерии приёмки (чеклист проверки)

Проверяющий делает:

### А. Проверка endpoints
1) `GET /health` → **200**, JSON содержит поля `status/db/time/app_version`  
2) Открывает `/` (или `/ui`) → видит страницу статуса, она показывает данные из `/health`  
3) Останавливает Postgres → `GET /health` → **503** и `db=fail`  
4) Обновляет `/` (или нажимает Refresh) → видит `db=fail` (страница не падает)

Если всё это выполнено — **MUST закрыт**.

---

## 6) Рекомендованная реализация (чтобы не ошибиться)

### 6.1. Точка входа URL
- `/health` должен быть доступен всегда
- `/` или `/ui` для страницы статуса

### 6.2. Где что размещать
- `apps/core/views.py` — функция `health()`
- `config/urls.py` — маршруты
- `templates/status.html` — HTML страница
- `apps/ml/service.py` — заглушки `load_model/predict/get_model_meta`

---

## 7) SHOULD / EXTRA (если хотите улучшить)

**SHOULD:**
- `pre-commit` с `black` + `ruff` (или аналог)
- один автотест на `/health` (`pytest` или `Django TestCase`)

**EXTRA:**
- `docker-compose.yml` (Django + Postgres)
- GitHub Actions (линтер + тесты)
- сборка «одной командой» через `docker-compose up`

---

## 8) Подсказка: минимальный фронт (ожидаемая логика)

Страница может быть очень простой:
- при загрузке вызывает JS‑функцию `refresh()`
- `refresh()` делает `fetch('/health')`
- кладёт поля в элементы на странице
- кнопка вызывает `refresh()`
